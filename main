contract icb{
public address owner;
public address ic_contract;
public address erc_contract;
public uint status;
public uint maxcap;
public mapping(address => uint)balances;
public uint balance;
public mapping(address => bool)done;

function icb(address ico,address erc,uint max){
 ico_contract=ico;
 erc_contract=erc;
 status=0;
 maxcap=max;
 }
 
 function deposit() returns (bool) payable{
 if(status>0)throw;
 if(msg.value==0)throw;
 if((balance+msg.value)<maxcap){ //se il deposito non eccede
 balances[msg.sender]+=msg.value;
 balance+=msg.value;
 }else{ //caso in cui il deposito eccede il maxcap o uguaglia il maxcap
 if((balance+msg.value)>maxcap){ //eccede , ne restituisce un po'
 if(!send(msg.sender,msg.value-(maxcap-balance)))throw;
 }
 balances[msg.sender]+=maxcap-balance;
 balance=maxcap;
 rate=erc.balance[this]/balance;
 status=1; //chiude la icb
 }
 }
 
 function withdraw() returns (bool) payable{
 if(status==0){ //se la icb è aperta
 uint temp=balances[msg.sender];
 balances[msg.sender]=0;
 balance-=temp;
 if(!send(msg.sender,temp))throw;
 }
 if(status==2){ //se le icb è chiusa
 balances[msg.sender]=0;
 if(!erc.transfer(msg.sender,balances[msg.sender]*rate))throw;
 }
 }
 

 function shoot(string str){
 if(!ic.deposit(balance))throw;
  IC ic= IC(ic_contract);
  ic.call.value(balance).gas(1500)(bytes4(sha3(str))); //calls the requested function at the ic contract
 }

}
